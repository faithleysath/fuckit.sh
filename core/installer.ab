import { env_var_get, echo_error, echo_warning, echo_info, echo_success, input_confirm } from "std/env"
import { split, replace } from "std/text"
import { array_contains } from "std/array"
import { dir_exists, dir_create, file_chmod, file_exists } from "std/fs"
import { file_download } from "std/http"
import { compare_versions } from "../utils/utils.ab"

pub fun install(home_dir: Text, name: Text, civil_name: Text, version: Text, url: Text): Null {
    // First, check if already installed, just check version command directly
    let current_version = $ {name} --version 2> /dev/null $ failed : let current_version = ""

    if current_version == "" :
        echo_info(trust env_var_get("MSG_INSTALL_START"))
    else {
        let comparison = compare_versions(current_version, version) failed : let comparison = -1
        if comparison == -1 {
            let tpl = trust env_var_get("MSG_INSTALL_UPGRADE_AVAILABLE")
            let msg = replace(replace(tpl, "\{version}", version), "\{current_version}", current_version)
            echo_warning(msg)
        } else {
            let tpl = trust env_var_get("MSG_INSTALL_LATEST")
            let msg = replace(tpl, "\{current_version}", current_version)
            echo_info(msg)
            exit 0
        }
    }
    if home_dir == "" :
        echo_error(trust env_var_get("MSG_ERR_NO_HOME"))

    // Installation / Update process (they are the same here)
    // Step1: Check if the dir exists
    let bin_dir = home_dir + "/.local/bin"
    let bin_path = bin_dir + "/" + name
    if not dir_exists(bin_dir) {
        let tpl = trust env_var_get("MSG_INSTALL_CREATE_DIR")
        let msg = replace(tpl, "\{bin_dir}", bin_dir)
        echo_info(msg)
        dir_create(bin_dir)
    }
    // Step2: Check if bin_dir is in PATH
    let path_env = trust env_var_get("PATH")
    // Step3: Download the script and place it in bin_dir
    let tpl_download = trust env_var_get("MSG_INSTALL_DOWNLOADING")
    let msg_download = replace(replace(tpl_download, "\{bin_dir}", bin_dir), "\{url}", url)
    echo_info(msg_download)
    if not file_download(url, bin_path):
        echo_error(trust env_var_get("MSG_ERR_NO_DOWNLOADER"))
    // Step4: Make it executable
    if not file_chmod(bin_path, "+x"):
        let tpl = trust env_var_get("MSG_ERR_CHMOD_FAILED")
        let msg = replace(tpl, "\{bin_path}", bin_path)
        echo_error(msg)
    // Step5: Verify installation
    let installed_version = $ {bin_path} --version 2> /dev/null $ failed : let installed_version = ""
    if installed_version == "" {
        echo "Verbose Information:"
        echo "  - Home Directory: {home_dir}"
        echo "  - Binary Path: {bin_path}"
        echo "  - Target Version: {version}"
        echo "  - Current Version: {current_version}"
        echo "  - Installed Version: {installed_version}"
        echo "  - PATH: {path_env}"
        echo_error(trust env_var_get("MSG_ERR_INSTALL_FAILED"))
    } else :
        let tpl = trust env_var_get("MSG_INSTALL_SUCCESS")
        let msg = replace(replace(tpl, "\{installed_version}", installed_version), "\{bin_path}", bin_path)
        echo_success(msg)
        // Step 6: Create a civilized alias
        let civil_path = bin_dir + "/" + civil_name
        if not file_exists(civil_path) {
            let tpl_alias = trust env_var_get("MSG_CIVIL_ALIAS_CREATING")
            let msg_alias = replace(tpl_alias, "\{civil_name}", civil_name)
            echo_info(msg_alias)
            $ ln -s "{bin_path}" "{civil_path}" $ failed {
                let tpl_alias_fail = trust env_var_get("MSG_CIVIL_ALIAS_FAILED")
                let msg_alias_fail = replace(replace(replace(tpl_alias_fail, "\{civil_name}", civil_name), "\{bin_path}", bin_path), "\{civil_path}", civil_path)
                echo_warning(msg_alias_fail)
            }
        }
    // Step7: Warn if bin_dir is not in PATH
    if path_env != "" and not array_contains(split(path_env, ":"), bin_dir) {
        let tpl = trust env_var_get("MSG_WARN_NOT_IN_PATH")
        let msg = replace(tpl, "\{bin_dir}", bin_dir)
        echo_warning(msg)
        echo_info("You can add the following line to your shell profile (e.g., ~/.bashrc, ~/.zshrc):")
        echo_info("export PATH=$PATH:{bin_dir}")
    }
}

pub fun uninstall(home_dir: Text, name: Text): Null {
    if home_dir == "" {
        echo_error(trust env_var_get("MSG_ERR_NO_HOME"))
        exit 1
    }

    let bin_dir = home_dir + "/.local/bin"
    let bin_path = bin_dir + "/" + name
    let config_dir = home_dir + "/.fuckit"

    if not file_exists(bin_path) {
        let tpl = trust env_var_get("MSG_UNINSTALL_NOT_INSTALLED") // Need to add this key
        let msg = replace(tpl, "\{bin_path}", bin_path)
        echo_warning(msg)
        exit 0
    }

    echo_info(trust env_var_get("MSG_UNINSTALL_START"))

    // Find and remove all symbolic links (personas/aliases)
    let tpl_search = trust env_var_get("MSG_UNINSTALL_SEARCHING_ALIASES")
    echo_info(replace(tpl_search, "\{bin_dir}", bin_dir))
    let aliases = trust $ find "{bin_dir}" -type l -lname "*/{name}" $
    if aliases != "" {
        for alias_path in lines(aliases) {
            let tpl = trust env_var_get("MSG_UNINSTALL_REMOVE_ALIAS")
            echo_info(replace(tpl, "\{alias_path}", alias_path))
            $ rm "{alias_path}" $ failed {
                let tpl_fail = trust env_var_get("MSG_UNINSTALL_ERR_REMOVE_ALIAS") // Need to add this key
                echo_warning(replace(tpl_fail, "\{alias_path}", alias_path))
            }
        }
    } else {
        echo_info(trust env_var_get("MSG_UNINSTALL_NO_ALIASES"))
    }

    // Remove the main executable
    let tpl_rm_exec = trust env_var_get("MSG_UNINSTALL_REMOVE_EXEC")
    echo_info(replace(tpl_rm_exec, "\{bin_path}", bin_path))
    $ rm "{bin_path}" $ failed {
        let tpl = trust env_var_get("MSG_UNINSTALL_ERR_REMOVE_EXEC") // Need to add this key
        echo_error(replace(tpl, "\{bin_path}", bin_path))
        exit 1
    }

    // Ask to remove the configuration directory
    if dir_exists(config_dir) {
        let tpl = trust env_var_get("MSG_UNINSTALL_CONFIRM_RM_CONFIG")
        if input_confirm(replace(tpl, "\{config_dir}", config_dir), false) {
            let tpl_rm_dir = trust env_var_get("MSG_UNINSTALL_RM_CONFIG_DIR")
            echo_info(replace(tpl_rm_dir, "\{config_dir}", config_dir))
            $ rm -r "{config_dir}" $ failed {
                let tpl_fail = trust env_var_get("MSG_UNINSTALL_ERR_RM_CONFIG") // Need to add this key
                echo_error(replace(tpl_fail, "\{config_dir}", config_dir))
                exit 1
            }
        } else {
            let tpl_keep = trust env_var_get("MSG_UNINSTALL_KEEP_CONFIG_DIR")
            echo_info(replace(tpl_keep, "\{config_dir}", config_dir))
        }
    }

    echo_success(trust env_var_get("MSG_UNINSTALL_SUCCESS"))
}
