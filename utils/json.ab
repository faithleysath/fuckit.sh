import { split_chars } from "std/text"
import { execute_python3_script, get_python_info } from "./system.ab"
import { is_command } from "std/env"

pub fun safe_escape_json_jq(text: Text): Text? {
    return $ jq -rn --arg s "{text}" '\$s | @json' $? // already enclosed in quotes
}

pub fun safe_escape_json_fallback(text: Text): Text {
    if text == "" :
        return "\"\""

    let chars = split_chars(text)
    let escaped_text = ""
    for char in chars {
        if {
            char == "\"" :
                escaped_text += "\\\""
            char == "\\" :
                escaped_text += "\\\\"
            char == "\n" :
                escaped_text += "\\n"
            else :
                escaped_text += char
        }
    }
    return "\"{escaped_text}\""
}

pub fun extract_json_value_jq(json_text: Text, path: Text): Text? {
    return $ jq -rn --argjson j "{json_text}" --arg p "{path}" '\$j | getpath(\$p | split(".") | map(tonumber? // .))' $?
}

pub fun safe_escape_json_py(text: Text): Text? {
    let script = "import json,sys;print(json.dumps(sys.argv[1] if len(sys.argv) > 1 else ''))"
    return execute_python3_script(script, [text])?
}

pub fun extract_json_value_py(json_text: Text, path: Text): Text? {
    let script = "import json,sys;d=json.loads(sys.argv[1]);p=sys.argv[2].split('.');v=d;
try:
    for k in p: v=v[int(k) if k.isdigit() and isinstance(v, list) else k]
    print(json.dumps(v) if isinstance(v,(dict,list)) else v)
except:print('null')"
    return execute_python3_script(script, [json_text, path])?
}

pub fun raw_unescape_json_value(text: Text): Text {
    let chars = split_chars(text)
    let unescaped_text = ""
    let i = 0
    let text_len = len(chars)

    loop {
        if i >= text_len {
            break
        }

        let char = chars[i]
        if char == "\\" {
            if i + 1 < text_len {
                let next_char = chars[i+1]
                if {
                    next_char == "\\" {
                        unescaped_text += "\\"
                    }
                    next_char == "\"" {
                        unescaped_text += "\""
                    }
                    next_char == "n" {
                        unescaped_text += "\n"
                    }
                    else {
                        unescaped_text += char
                        unescaped_text += next_char
                    }
                }
                i += 2
            } else {
                unescaped_text += char
                i += 1
            }
        } else {
            unescaped_text += char
            i += 1
        }
    }
    return unescaped_text
}

pub fun extract_json_value_sed_fallback(json_text: Text, path: Text): Text? {
    let key = trust $ awk -F. '\{print \$NF}' <<< "{path}" $
    let value = trust $ tr -d '\n' <<< "{json_text}" | sed -E -n 's/.*"'{key}'"[[:space:]]*:[[:space:]]*"(([^"]|\\\\")*)".*/\1/p' $
    if value == "" {
        fail 1
    }
    return value
}

pub fun safe_escape_json(text: Text): Text? {
    if is_command("jq") {
        let result = safe_escape_json_jq(text) failed {
            if len(get_python_info()) > 0 {
                return safe_escape_json_py(text)?
            }
            return safe_escape_json_fallback(text)
        }
        return result
    }
    if len(get_python_info()) > 0 {
        return safe_escape_json_py(text)?
    }
    return safe_escape_json_fallback(text)
}

pub fun extract_json_value(json_text: Text, path: Text): Text? {
    if is_command("jq") {
        let result = extract_json_value_jq(json_text, path) failed {
            if len(get_python_info()) > 0 {
                return extract_json_value_py(json_text, path)?
            }
            let sed_result = extract_json_value_sed_fallback(json_text, path)?
            return raw_unescape_json_value(sed_result)
        }
        return result
    }
    if len(get_python_info()) > 0 {
        return extract_json_value_py(json_text, path)?
    }
    let sed_result = extract_json_value_sed_fallback(json_text, path)?
    return raw_unescape_json_value(sed_result)
}
