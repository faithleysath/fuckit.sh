import { split_chars } from "std/text"
import { execute_python3_script, get_python_info } from "./system.ab"
import { is_command } from "std/env"

pub fun safe_escape_json_jq(text: Text): Text? {
    return $ jq -rn --arg s "{text}" '\$s | @json' $? // already enclosed in quotes
}

pub fun safe_escape_json_fallback(text: Text): Text {
    if text == "" :
        return "\"\""

    let chars = split_chars(text)
    let escaped_text = ""
    for char in chars {
        if {
            char == "\"" :
                escaped_text += "\\\""
            char == "\\" :
                escaped_text += "\\\\"
            char == "\n" :
                escaped_text += "\\n"
            else :
                escaped_text += char
        }
    }
    return "\"{escaped_text}\""
}

pub fun extract_json_value_jq(json_text: Text, path: Text): Text? {
    return $ jq -rn --argjson j "{json_text}" --arg p "{path}" '\$j | getpath(\$p | split(".") | map(tonumber? // .))' $?
}

pub fun safe_escape_json_py(text: Text): Text? {
    let script = "import json,sys;print(json.dumps(sys.argv[1] if len(sys.argv) > 1 else ''))"
    return execute_python3_script(script, [text])?
}

pub fun extract_json_value_py(json_text: Text, path: Text): Text? {
    let script = "import json,sys;d=json.loads(sys.argv[1]);p=sys.argv[2].split('.');v=d;
try:
    for k in p: v=v[int(k) if k.isdigit() and isinstance(v, list) else k]
    print(json.dumps(v) if isinstance(v,(dict,list)) else v)
except:print('null')"
    return execute_python3_script(script, [json_text, path])?
}

pub fun safe_escape_json(text: Text): Text? {
    if is_command("jq") {
        return safe_escape_json_jq(text)?
    }
    if len(get_python_info()) > 0 {
        return safe_escape_json_py(text)?
    }
    return safe_escape_json_fallback(text)
}

pub fun extract_json_value(json_text: Text, path: Text): Text? {
    if is_command("jq") {
        return extract_json_value_jq(json_text, path)?
    }
    if len(get_python_info()) > 0 {
        return extract_json_value_py(json_text, path)?
    }
    fail 1 // No fallback available for extraction
}
