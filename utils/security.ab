import { split_lines, text_contains, starts_with } from "std/text"

fun custom_match_regex(text: Text, pattern: Text): Bool {
    silent $ printf "%s" "{text}" | grep -qE -- "{pattern}" $ failed {
        return false
    }
    return true
}

// Checks the LLM output script file according to strict security rules.
//
// --- Security Rules ---
// 0. Disallow Shebang (`#!`).
// 1. Allow empty lines (^\s*$).
// 2. Allow comment lines (^\s*#).
// 3. Allow `echo '...'` (single quotes) format, supporting escaped quotes (\').
// 4. Allow `exit 201`, `exit 202` and `exit 203`.
// --------------------

pub fun check_llm_output(script_content: Text): Bool {
    let lines = split_lines(script_content)

    for line in lines {
        // Rule 0: Disallow Shebang
        if starts_with(line, "#!"):
            return false

        // Step 1: Check for empty lines
        if custom_match_regex(line, "^\s*$"):
            continue

        // Step 2: Check for comment lines
        if custom_match_regex(line, "^\s*#.*$"):
            continue

        // Rule 3: Allow `echo '...'` by checking an ASCII-only version of the line.
        // Non-ASCII chars are replaced with spaces to preserve structure for the regex check,
        // which prevents both Unicode issues and command injection.
        let sanitized_line = trust $ printf "%s" "{line}" | tr -c '\11\12\15\40-\176' ' ' $
        if custom_match_regex(sanitized_line, "^\s*echo\s+'([^']|\\\\')*'\s*$"):
            continue

        // Rule 4: Allow `exit 201`, `exit 202` and `exit 203`
        if line == "exit 201" or line == "exit 202" or line == "exit 203":
            continue

        // If the code reaches here, the line does not match any known safe patterns.
        return false
    }

    // All lines have passed the check.
    return true
}
