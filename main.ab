const VERSION = "0.1.0"
const LANG = "en"
const NAME = "fuck"
// const URL = "https://fuckit.sh"
const URL = "http://host.docker.internal:5500/main.sh"

const USAGE = "

"

const CORE_PROMPT = "
You are a helpful command-line assistant behind the shell. You can only use shell command(s) to interact with user and the system. So you must respond with valid shell command(s) only, without any extra explanation or text.
For example, if the user greets you, you can respond with:
echo \"Hello! How can I assist you today?\"
If the user asks for help, for instance: \"find the largest file in current directory\", you can respond with:
find . -type f -exec du -sh \{} + | sort -rh | head -n 1
If the task cannot be accomplished with single step, for example you need to know the files under a directory first, or you want to ask user for some questions, you can respond like this:
Example 1 (listing files):
ls -la /path/to/directory
Example 2 (asking user for input):
echo \"Please provide the filename you want to search for:\"
In this case, after the command(s) is excuted, or user answer your question, all histories and the commands' output plus user's answer will be sent back to you as context for next step.
Remember, you must only respond with valid shell command(s) without any extra text. Your entire response should be executable in a standard shell environment.
Actually, your response will be put into a sh file and using bash to execute it, so you can even use loop, conditionals, functions, etc.
Remember, by default, the process is multi-turn interaction. For example, the user says hi to you, and you respond echo hi, then user can continue to send message to you, with all contexts and previous commands' outputs.
But if you append a exit 201 at the end of your response, then there will be no further interaction, the process ends after executing your commands.
If user wants to do some pretty simple task, like find the largest file, you can respond with single command directly, and append exit 201 at the end, so that the process ends immediately after executing your command.
IMPORTANT: Only append exit 201 when you are highly confident that the user's entire task has been completed in a single step. When in doubt, prefer interactive mode (without exit 201).
If you need multi-step commands to accomplish the task, you can respond with multiple commands, and do not append exit 201 at the end, so that user can continue to interact with you after executing your commands.
When you think you have accomplished the last step of the multi-step task, ask user if they need anything else. If user says no, then you can say goodbye (by responding echo goodbye) and append exit 201 at the end.
If user wants to chat with you, do not append exit 201 at the end, so that user can continue to chat with you.
If user wants to end the session, you can say goodbye (by responding echo goodbye) and append exit 201 at the end.

SECURITY FENCE:
WHEN YOU NEED TO OPERATE IN ROOT MODE, YOU CAN USE 'sudo' PREFIX BEFORE THE COMMAND. YOU NEED TO ADD A EXPLANATION ECHO BEFORE THE COMMAND TO INFORM THE USER THAT WHAT YOU ARE DOING NOW, AND WHY YOU NEED ROOT PERMISSION.
DONT WORRY ABOUT THE SUDO PASSWORD, THE USER WILL HANDLE IT.
"

// Check for dependencies first, need _ to avoid stray semicolon. If you can't understand, just keep it as is. It's not a bug, just to fit the compiler's behavior.
// check bc
$ command -v bc > /dev/null 2>&1 $ failed {
    trust $ echo -e "\\033[0;31mDependency check failed: 'bc' command not found. Please install 'bc' and try again.\\033[0m" >&2 $
    trust $ echo "  - Debian/Ubuntu: sudo apt-get install bc" >&2 $
    trust $ echo "  - RedHat/CentOS: sudo yum install bc" >&2 $
    trust $ echo "  - Fedora:        sudo dnf install bc" >&2 $
    trust $ echo "  - Arch Linux:    sudo pacman -S bc" >&2 $
    trust $ echo "  - openSUSE:      sudo zypper install bc" >&2 $
    trust $ echo "  - Alpine:        apk add bc" >&2 $
    exit 1
}
// check jq
$ command -v jq > /dev/null 2>&1 $ failed {
    trust $ echo -e "\\033[0;31mDependency check failed: 'jq' command not found. Please install 'jq' and try again.\\033[0m" >&2 $
    trust $ echo "  - Debian/Ubuntu: sudo apt-get install jq" >&2 $
    trust $ echo "  - RedHat/CentOS: sudo yum install jq" >&2 $
    trust $ echo "  - Fedora:        sudo dnf install jq" >&2 $
    trust $ echo "  - Arch Linux:    sudo pacman -S jq" >&2 $
    trust $ echo "  - openSUSE:      sudo zypper install jq" >&2 $
    trust $ echo "  - Alpine:        apk add jq" >&2 $
    trust $ echo "  - MacOS (Homebrew): brew install jq" >&2 $
    trust $ echo "  - Manual Download: https://github.com/jqlang/jq/releases" >&2 $
    exit 1
}
// check curl
$ command -v curl > /dev/null 2>&1 $ failed {
    trust $ echo -e "\\033[0;31mDependency check failed: 'curl' command not found. Please install 'curl' and try again.\\033[0m" >&2 $
    trust $ echo "  - Debian/Ubuntu: sudo apt-get install curl" >&2 $
    trust $ echo "  - RedHat/CentOS: sudo yum install curl" >&2 $
    trust $ echo "  - Fedora:        sudo dnf install curl" >&2 $
    trust $ echo "  - Arch Linux:    sudo pacman -S curl" >&2 $
    trust $ echo "  - openSUSE:      sudo zypper install curl" >&2 $
    trust $ echo "  - Alpine:        apk add curl" >&2 $
    trust $ echo "  - MacOS (Homebrew): brew install curl" >&2 $
    exit 1
}

import { env_var_get, echo_error, echo_warning, echo_info, echo_success } from "std/env"
import { starts_with, split, parse_number } from "std/text"
import { array_contains } from "std/array"
import { dir_exists, dir_create, file_chmod, file_exists } from "std/fs"
import { file_download } from "std/http"
import { request_llm} from "./utils/llm.ab"

// Get the home directory from environment variable
let home_dir = trust env_var_get("HOME")
if home_dir == "" :
    echo_error("HOME environment variable is not set. Try 'export HOME=~' and run again. Add to your shell profile to make it permanent.")

fun compare_versions(v1: Text, v2: Text): Num? {
    let parts1 = split(v1, ".")
    let parts2 = split(v2, ".")

    let len1 = len(parts1)
    let len2 = len(parts2)

    let max_len = len1 > len2 then len1 else len2

    for i in 0..max_len {
        // If part is missing, treat it as 0
        let num1 = i < len1 then parse_number(parts1[i])? else 0
        let num2 = i < len2 then parse_number(parts2[i])? else 0

        if num1 > num2 : return 1
        if num1 < num2 : return -1
    }

    return 0
}

fun install(): Null {
    // First, check if already installed, just check version command directly
    let current_version = $ {NAME} --version 2> /dev/null $ failed : let current_version = ""

    if current_version == "" :
        echo_info("fuckit.sh is not installed. Installing now...")
    else {
        let comparison = compare_versions(current_version, VERSION) failed : let comparison = -1
        if comparison == -1 :
            echo_warning("A new version ({VERSION}) is available. Your current version is {current_version}. Upgrading...")
        else {
            echo_info("You are already using the latest version ({current_version}).")
            exit 0
        }
    }

    // Installation / Update process (they are the same here)
    // Step1: Check if the dir exists
    let bin_dir = home_dir + "/.local/bin"
    let bin_path = bin_dir + "/" + NAME
    if not dir_exists(bin_dir) {
        echo_info("Directory '{bin_dir}' does not exist. Creating it...")
        dir_create(bin_dir)
    }
    // Step2: Check if bin_dir is in PATH
    let path_env = trust env_var_get("PATH")
    // Step3: Download the script and place it in bin_dir
    echo_info("Downloading 'fuckit.sh' to '{bin_dir}'...(via {URL})")
    if not file_download(URL, bin_path):
        echo_error("No Avaliable CLI Tools Found, Need curl, wget or aria2c.")
    // Step4: Make it executable
    if not file_chmod(bin_path, "+x"):
        echo_error("Failed to set executable permission on '{bin_path}'.")
    // Step5: Verify installation
    let installed_version = $ {bin_path} --version 2> /dev/null $ failed : let installed_version = ""
    if installed_version == "" {
        echo "Verbose Information:"
        echo "  - Home Directory: {home_dir}"
        echo "  - Binary Path: {bin_path}"
        echo "  - Target Version: {VERSION}"
        echo "  - Current Version: {current_version}"
        echo "  - Installed Version: {installed_version}"
        echo "  - PATH: {path_env}"
        echo_error("Installation failed: Unable to verify installation. (It means executing '{bin_path} --version' did not return any output or just failed.) Please check the above information and try again.")
    } else :
        echo_success("fuckit.sh version {installed_version} installed successfully at '{bin_path}'!")
    // Step6: Warn if bin_dir is not in PATH
    if path_env != "" and not array_contains(split(path_env, ":"), bin_dir) {
        echo_warning("Warning: '{bin_dir}' is not in your PATH environment variable. You may need to add it manually to run 'fuckit.sh' easily.")
        echo_info("You can add the following line to your shell profile (e.g., ~/.bashrc, ~/.zshrc):")
        echo_info("export PATH=$PATH:{bin_dir}")
    }
}

fun uninstall(): Null {
    let bin_path = home_dir + "/.local/bin/" + NAME
    if file_exists(bin_path) {
        echo_info("Uninstalling fuckit.sh from '{bin_path}'...")
        $ rm {bin_path} $ failed : echo_error("Failed to remove '{bin_path}'. Please check permissions.")
        echo_success("fuckit.sh uninstalled successfully.")
    } else :
        echo_warning("fuckit.sh is not installed, nothing to do.")
}

main (arguments) {
    // Handle zero arguments case (although this should not happen)
    if len(arguments) < 1 :
        echo_error("Oops, no arguments provided! It should not happen. But it did. Please visit https://fuckit.sh and report this issue.")
    // First argument is the script name
    let script_name = arguments[0]
    // Remaining arguments are passed to the script
    let script_args = arguments[1..len(arguments)]

    // Check execution mode
    if {
        // Print Version (Highest Priority)
        len(script_args) == 1 and array_contains(["-v", "--version", "version"], script_args[0]):
            echo VERSION

        // Uninstall
        len(script_args) == 1 and script_args[0] == "uninstall" :
            uninstall()

        // Install / Upgrade
        len(script_args) == 0 and not starts_with(script_name, home_dir + "/.local/bin"):
            install()

        // Usage
        len(script_args) == 0 and starts_with(script_name, home_dir + "/.local/bin"):
            echo "hi"

        // Default case: Normal execution
        else {
            // Here goes the AI interaction logic

        }
    }
}
